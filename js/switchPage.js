let generatedEltOnLoad = {
    php: {
        generatedDiv: [
            {
                path: "PHP/films_php_opti.mp4",
                typeDiv: "video",
            },
            {
                desc: "CRUD / PDO",
                content: "Site web interactif dédié à la visualisation de films et de leurs distributions, offrant une expérience fluide de découverte cinématographique. Les utilisateurs peuvent explorer des collections d'auteurs et de types de films, tout en bénéficiant de filtres pratiques.",
                typeDiv: "text",
            },
            {
                path: "PHP/meteo_php_opti.mp4",
                typeDiv: "video",
            },
            {
                desc: "SYMFONY / Back Office / TESTS",
                content: "Plateforme de gestion de contacts permettant d'organiser et de retrouver facilement des personnes selon différentes catégories. L'interface épurée et intuitive facilite la navigation et l'accès rapide aux informations recherchées. Idéal pour structurer et centraliser un réseau de contacts de manière efficace.",
                typeDiv: "text",
            },
            {
                desc: "SYMFONY / API / COMPTES",
                content: "Récupération et affichage des données météorologiques. Les utilisateurs peuvent créer un compte et ajouter des adresses, elles aussi récupérées via API, afin d'obtenir en temps réel les prévisions météo de différents lieux.",
                typeDiv: "text",
            },
            {
                path: "PHP/contacts_opti.mp4",
                typeDiv: "video",
            },
            {
                desc: "Analyse / SYMFONY / SCRUM / TESTS",
                content: "Système de gestion complet pour un zoo, permettant d'administrer efficacement les familles et catégories d'animaux, ainsi que la gestion des enclos et des événements. L'interface offre une vue d'ensemble claire et intuitive, facilitant l'organisation et le suivi des différentes activités du parc zoologique.",
                typeDiv: "text",
            },
            {
                path: "PHP/zooteckpark_opti.mp4",
                typeDiv: "video",
            },
        ],

        logo1: "logo/php-nobg.png",
        logo2: "logo/symfony-nobg.png",
        background: "phpbg.png",
    },
    js: {
        generatedDiv: [
            {
                path: "PHP/zooteckpark_opti.mp4",
                typeDiv: "video",
            },
            {
                desc: "REACT / API / REFONTE",
                content: "Refonte complète du projet de gestion de zoo avec React et Symfony API. Cette transformation vise à améliorer l'expérience utilisateur avec une interface dynamique et réactive, tout en optimisant la gestion des données grâce à une API robuste. Ce système garantit une gestion de données robuste. Grâce à cette refonte, l'application devient plus évolutive, performante et maintenable sur le long terme.",
                typeDiv: "text",
            },
            {
                path: "JS/movies_js_opti.mp4",
                typeDiv: "video",
            },
            {
                desc: "REACT / PWA / JWT / REDUX / CACHE",
                content: "Développement d'une application de todolist en Progressive Web App (PWA) offrant une expérience fluide et accessible sur tous les appareils. L'application intègre une gestion sécurisée des utilisateurs via un système de token, permettant une authentification fiable et persistante. Grâce au mode hors ligne, les utilisateurs peuvent accéder à leur tâche grâce au cache, avec une synchronisation automatique dès le retour en ligne.",
                typeDiv: "text",
            },
            {
                desc: "JS / WEBPACK / AJAX / API",
                content: "Initiation au Javascript à l'aide d'un site de visualisation de film basique",
                typeDiv: "text",
            },
            {
                path: "JS/todolist_opti.mp4",
                typeDiv: "video",
            },
            {
                desc: "WEBGL",
                content: "Projet d'initiation à WebGL, dans l'univers de la 3D en explorant les bases essentielles du rendu graphique sur le web. À travers la gestion des formes, des placements et des dimensions, il permet de comprendre comment manipuler des objets dans un espace tridimensionnel.L'accent est mis sur la modification dynamique des couleurs et des transformations (translation, rotation, mise à l’échelle), offrant ainsi une première approche des shaders et de la programmation graphique bas niveau.",
                typeDiv: "text",
            },
            {
                path: "JS/webgl_opti.mp4",
                typeDiv: "video",
            },
        ],
        logo1: "logo/js_minia.png",
        logo2: "logo/react-nobg.png",
        background: "reactbg.png",
    },
    python: {
        generatedDiv: [
            {
                path: "PYTHON/meteo_py_opti.mp4",
                typeDiv: "video",
            },
            {
                desc: "API / SQL / COMPLÉXITÉ / OPENWEATHERMAP",
                content: "Développement d'une plateforme de récupération et d'exploitation des données GPS via API, permettant d'obtenir les données météorologiques des emplacements récupérés. Ces informations sont ensuite stockées dans une base de données afin d'analyser et comparer différents systèmes de gestion de données. Grâce à une architecture optimisée, l'application assure une collecte fiable et automatisée des données, offrant ainsi un cadre efficace pour l'étude et l'amélioration des modèles de gestion d'informations météorologiques et géolocalisées.",
                typeDiv: "text",
            },
            {
                path: "PYTHON/lawsbyrinthe_opti.mp4",
                typeDiv: "video",
            },
            {
                desc: "PYGAME / AUTOMATE",
                content: "Développement du backend du jeu du Démineur en utilisant Pygame, avec une gestion optimisée de la grille, des mines et des interactions utilisateur. Le code implémente la génération dynamique du plateau avec un placement aléatoire des mines, ainsi qu'un algorithme de révélation des cases adjacentes pour une expérience fluide et réactive. La logique de détection des mines, des victoires et des défaites est soigneusement intégrée, garantissant un gameplay fidèle au jeu classique. Un modèle de résolution intelligente a aussi été implémentée se basant sur le nombre de mine adjacente et les probabilités.",
                typeDiv: "text",
            },
            {
                desc: "PYGAME / AUTOMATE / MAZE",
                content: "Développement d’un générateur de labyrinthes aléatoires en explorant différentes approches pour structurer les chemins et impasses de manière unique à chaque exécution. Plusieurs techniques de résolution ont été mises en place, permettant une exploration automatisée du labyrinthe et une analyse des différentes stratégies d’optimisation des trajets. Enfin, une interface interactive a été conçue avec Pygame, permettant aux utilisateurs de visualiser en temps réel la création et la résolution du labyrinthe, rendant ainsi le programme plus immersif et interactif.",
                typeDiv: "text",
            },
            {
                path: "PYTHON/demineur_opti.mp4",
                typeDiv: "video",
            },
            {
                desc: "Quantification (musique => image) / Fichiers Binaire",
                content: "Développement d'un programme de stéganographie permettant de dissimuler des informations au sein d'images de manière imperceptible. Le programme encode des données en modifiant subtilement les pixels, garantissant que l'image finale reste visuellement identique à l’originale pour l'œil humain. Une fonctionnalité de décodage permet d’extraire les informations cachées, assurant ainsi une communication discrète et sécurisée. Grâce à une approche optimisée, le programme équilibre efficacité et discrétion, offrant un outil performant pour l’exploration des techniques de dissimulation de données.",
                typeDiv: "text",
            },
            {
                desc: "Compression / Binaire / Huffman",
                content: "Développement d’un programme de compression de fichiers basé sur l’algorithme de l’arbre de Huffman. Le programme analyse la fréquence des caractères dans un fichier, génère un arbre binaire optimal et encode les données en utilisant des codes binaires de longueur variable. Cette approche permet une réduction efficace de la taille des fichiers tout en conservant leur intégrité. Une fonction de décompression est également intégrée, permettant de restaurer fidèlement les données d’origine. Ce projet illustre les principes de la compression sans perte et l’optimisation du stockage des informations.",
                typeDiv: "text",
            },
        ],
        logo1: "logo/python-nobg.png",
        logo2: "logo/pygame.png",
        background: "pythonbg.png",
    },
    csharp: {
        generatedDiv: [
            {
                path: "CSHARP/navale_opti.mp4",
                typeDiv: "video",
            },
            {
                desc: "TERMINAL / AUTOMATE",
                content: "Développement d'un jeu de bataille navale jouable dans un terminal, où le joueur affronte une intelligence artificielle. Le programme génère aléatoirement le placement des navires et permet au joueur d’interagir via une interface textuelle intuitive. L’intelligence artificielle analyse les tirs pour adapter sa stratégie, rendant chaque partie dynamique et imprévisible. Une gestion optimisée des tours, des impacts et de la victoire assure une expérience fidèle au jeu classique tout en exploitant les possibilités offertes par la programmation en C#",
                typeDiv: "text",
            },
            {
                path: "CSHARP/pays_opti.mp4",
                typeDiv: "video",
            },
            {
                desc: "TERMINAL / GRAPHIQUE",
                content: "Développement du jeu Castle Card en deux versions : une version en terminal et une version graphique. La version textuelle permet d’affronter un adversaire en suivant les règles du jeu à travers des interactions simples et intuitives. La version graphique enrichit l’expérience avec une interface visuelle dynamique, facilitant la gestion des cartes et l’affichage des actions en cours. Le moteur de jeu gère les mécaniques stratégiques, les effets des cartes et les conditions de victoire, garantissant une expérience immersive et équilibrée dans les deux modes.",
                typeDiv: "text",
            },
            {
                desc: "MVVC / RAZOR / BLAZOR",
                content: "Développement d'un site web de gestion et d'affichage des pays en suivant l’architecture MVVC, assurant une organisation claire du code et une meilleure maintenabilité. L’application permet de visualiser, filtrer et gérer les informations relatives aux pays de manière efficace. L'intégration de Blazor avec Razor ajoute une interface interactive et réactive, offrant une expérience utilisateur fluide grâce au rendu côté client.",
                typeDiv: "text",
            },
            {
                path: "CSHARP/castle_opti.mp4",
                typeDiv: "video",
            },
            {
                desc: "MAUI",
                content: "Développement de petites applications multiplateformes avec .NET MAUI, offrant une interface moderne et responsive. Parmi les réalisations, une calculatrice avancée intégrant la gestion de la TVA pour simplifier les calculs financiers, ainsi qu’une application de gestion d’annuaire. Une autre application dédiée à la gestion de citations offre la possibilité d’enregistrer, classer et afficher des citations inspirantes.",
                typeDiv: "text",
            },
            {
                path: "CSHARP/maui_opti.mp4",
                typeDiv: "video",
            },
        ],
        logo1: "logo/csharp-nobg.png",
        logo2: "logo/csharp-nobg.png",
        background: "csharpbg.png",
    },
}
let eltToDisappear = null
let loaded = false
document.addEventListener('DOMContentLoaded', () => {
    // document.querySelectorAll('.text_desc, .video_show').forEach((elt) => elt.style.opacity = 1)
    // document.querySelectorAll('.navbar_rea > *').forEach((link) => {
    //     eltToDisappear = Array.from(document.querySelectorAll('.text_desc, .video_show'))
    //     link.addEventListener('click', (event) => {
    //         event.preventDefault()
    //         disappear()
    //
    //     })
    // })

    function disappear(fadeIn) {
        eltToDisappear = shuffleArray(eltToDisappear)
        fadeIn ? fadeInRandomElt(eltToDisappear.pop()) : fadeOutRandomElt(eltToDisappear.pop())
        if (eltToDisappear.length > 0) {
            setTimeout(() => disappear(fadeIn),250)
        } else {
            if (!fadeIn) {
                setTimeout(switchBG, 800)
            }
        }
    }
    function fadeOutRandomElt(elt) {
        if (elt.style.opacity > 0) {
            elt.style.opacity -= 0.15
            setTimeout(() => fadeOutRandomElt(elt), 100)
        }
    }

    function fadeInRandomElt(elt) {
        if (!elt.style.opacity) {
            elt.style.opacity = "0";
        }

        let opacity = parseFloat(elt.style.opacity);

        if (opacity < 1) {
            opacity += 0.15;
            elt.style.opacity = opacity.toString();
            setTimeout(() => fadeInRandomElt(elt), 100);
        }
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    function switchBG() {
        const oldImage = document.querySelector(".background_accueil.active");
        const newImage = document.querySelector(".background_accueil:not(.active)");
        const getParams = new URLSearchParams(window.location.search);
        const language = getParams.get("language");
        const direction = oldImage.id.includes('1') ? 'right' : 'left'
        console.log(direction)

        newImage.src = "/portfolio/img/background/" + generatedEltOnLoad[language]['background'];

        // Détermine la direction de l'animation
        const slideIn = direction === 'right' ? 'slideInRight' : 'slideInLeft';
        const slideOut = direction === 'right' ? 'slideOutRight' : 'slideOutLeft';

        // Ajoute la classe active à la nouvelle image
        newImage.classList.add("active");
        newImage.style.animation = `${slideIn} 1s forwards`;

        setTimeout(() => {
            oldImage.classList.remove("active");
            oldImage.style.animation = `${slideOut} 1s forwards`;
        }, direction === 'right' ? 1000 : 620);

        setTimeout(() => {
            load();
        }, 700);
    }






    function createDivVideo(path) {
        return `
        <span class="video_show" style="opacity: 0;">
            <video controls autoplay loop muted>
                <source src="/portfolio/video/${path}" type="video/mp4">
                Votre navigateur ne supporte pas la balise vidéo.
            </video>
        </span>`
    }

    function createDivTexte(desc, content) {
        return `
        <span class="text_desc" style="opacity: 0;">
            <span>${content}</span>
            <span class="recap_desc">${desc}</span>
        </span>
        `
    }
    function createDivLogo(image1, image2) {
        return `
        <span class="logo_show">
            <div class="hacking-container">
                <img id="image1" class="hacking-image active" src="/portfolio/img/${image1}" alt="${image1.split('/').pop()}">
                <img id="image2" class="hacking-image" src="/portfolio/img/${image2}" alt="${image2.split('/').pop()}">
            </div>
        </span>`
    }

    function loadPage(newPage) {
        generateNavBar()
        const content_global = document.querySelector(".content_global")
        content_global.innerHTML = ""
        for (let i = 0; i <= 3; i++) {
            content_global.innerHTML += generatedEltOnLoad[newPage]['generatedDiv'][i]["typeDiv"] === "text" ? createDivTexte(generatedEltOnLoad[newPage]['generatedDiv'][i]['desc'], generatedEltOnLoad[newPage]['generatedDiv'][i]['content']) : createDivVideo(generatedEltOnLoad[newPage]['generatedDiv'][i]['path'])
        }
        content_global.innerHTML += createDivLogo(generatedEltOnLoad[newPage]['logo1'], generatedEltOnLoad[newPage]['logo2'])
        for (let i = 4; i <= 7; i++) {
            content_global.innerHTML += generatedEltOnLoad[newPage]['generatedDiv'][i]["typeDiv"] === "text" ? createDivTexte(generatedEltOnLoad[newPage]['generatedDiv'][i]['desc'], generatedEltOnLoad[newPage]['generatedDiv'][i]['content']) : createDivVideo(generatedEltOnLoad[newPage]['generatedDiv'][i]['path'])
        }
        eltToDisappear = Array.from(document.querySelectorAll('.text_desc, .video_show'))
        if (!loaded) {
            loaded = true
            document.querySelector('.background_accueil.active').src = "/portfolio/img/background/" + generatedEltOnLoad[newPage]["background"]
            document.querySelector('.background_accueil:not(.active)').src = "/portfolio/img/background/" + generatedEltOnLoad[newPage]["background"]
        }

    }

    function load() {
        const getParams = new URLSearchParams(window.location.search)
        const language = getParams.get("language")
        document.querySelector('title').innerHTML = language.toUpperCase() + " - Haas Benjamin"
        loadPage(language)
        disappear(true)
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('video').forEach((video) => {
                video.playbackRate = 1.5;
            })
        })
        document.querySelectorAll(".btnSwitch").forEach(btn => {
            btn.addEventListener('click', (event) => {
                event.preventDefault()
                const getParams = new URLSearchParams(window.location.search)
                getParams.set("language", btn.value)
                history.replaceState(null, "", "?" + getParams.toString());
                document.querySelector('title').innerHTML = btn.value.toUpperCase() + " - Haas Benjamin"
                eltToDisappear = Array.from(document.querySelectorAll('.text_desc, .video_show'))
                disappear()
            })
        })
    }

    load()
    setTimeout(() => {
        switchImage();
    }, 3000)

})